# coding: utf-8

"""
    Container Security API

    # Authentication You must authenticate to the Qualys Cloud Platform using Qualys account credentials (user name and password) and get the JSON Web Token (JWT) before you can start using the Container Security APIs. Use the Qualys Authentication API to get the JWT.  **Example Authentication Curl Request**:  curl -X POST https://gateway/auth -H 'Content-Type: application/x-www-form-urlencoded' -d 'username=value1&password=passwordValue&token=true' where - gateway is the base URL to the Qualys API server where your account is located. - **username** and **password** are the credentials of the user account for which you want to fetch Container Security data. - **token** should be **true** - **Content-Type** should be **application/x-www-form-urlencoded**   # noqa: E501

    OpenAPI spec version: v1.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class RegistryApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cancel_cs_registry_schedule(self, registry_id, schedule_id, **kwargs):  # noqa: E501
        """Cancel registry schedule in your account.  # noqa: E501

        Cancel registry schedule in your account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_cs_registry_schedule(registry_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID/UUID of the registry you want to cancel the schedule for. (required)
        :param str schedule_id: Provide the ID/UUID of the schedule you want to cancel. You can only cancel schedules which are in the state: Created, Queued, Paused, Running, BaselineQueued or BasinelineRunning (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_cs_registry_schedule_with_http_info(registry_id, schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_cs_registry_schedule_with_http_info(registry_id, schedule_id, **kwargs)  # noqa: E501
            return data

    def cancel_cs_registry_schedule_with_http_info(self, registry_id, schedule_id, **kwargs):  # noqa: E501
        """Cancel registry schedule in your account.  # noqa: E501

        Cancel registry schedule in your account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_cs_registry_schedule_with_http_info(registry_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID/UUID of the registry you want to cancel the schedule for. (required)
        :param str schedule_id: Provide the ID/UUID of the schedule you want to cancel. You can only cancel schedules which are in the state: Created, Queued, Paused, Running, BaselineQueued or BasinelineRunning (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id', 'schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_cs_registry_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `cancel_cs_registry_schedule`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if ('schedule_id' not in params or
                params['schedule_id'] is None):
            raise ValueError("Missing the required parameter `schedule_id` when calling `cancel_cs_registry_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501
        if 'schedule_id' in params:
            path_params['scheduleId'] = params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/schedule/{scheduleId}/cancel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cs_acr_connector(self, body, **kwargs):  # noqa: E501
        """Create new ACR connector  # noqa: E501

        Create new ACR connector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_acr_connector(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AcrConnectorRequest body: Provide parameter values in the format shown under Example Value. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cs_acr_connector_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cs_acr_connector_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_cs_acr_connector_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create new ACR connector  # noqa: E501

        Create new ACR connector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_acr_connector_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AcrConnectorRequest body: Provide parameter values in the format shown under Example Value. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cs_acr_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_cs_acr_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/acr/connector', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cs_aws_connector(self, body, **kwargs):  # noqa: E501
        """Create new AWS connector  # noqa: E501

        Create new AWS connector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_aws_connector(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AwsConnectorRequest body: Provide parameter values in the format shown under Example Value. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cs_aws_connector_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cs_aws_connector_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_cs_aws_connector_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create new AWS connector  # noqa: E501

        Create new AWS connector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_aws_connector_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AwsConnectorRequest body: Provide parameter values in the format shown under Example Value. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cs_aws_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_cs_aws_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/aws/connector', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cs_gcp_connector(self, service_account_json, name, **kwargs):  # noqa: E501
        """Create new GCP connector  # noqa: E501

        Create new GCP connector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_gcp_connector(service_account_json, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_account_json: (required)
        :param str name: Provide the name for the connector (required)
        :param str description: Provide the description for the connector
        :param str connector_id: Provide the connector id for the connector
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cs_gcp_connector_with_http_info(service_account_json, name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cs_gcp_connector_with_http_info(service_account_json, name, **kwargs)  # noqa: E501
            return data

    def create_cs_gcp_connector_with_http_info(self, service_account_json, name, **kwargs):  # noqa: E501
        """Create new GCP connector  # noqa: E501

        Create new GCP connector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_gcp_connector_with_http_info(service_account_json, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_account_json: (required)
        :param str name: Provide the name for the connector (required)
        :param str description: Provide the description for the connector
        :param str connector_id: Provide the connector id for the connector
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_account_json', 'name', 'description', 'connector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cs_gcp_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_account_json' is set
        if ('service_account_json' not in params or
                params['service_account_json'] is None):
            raise ValueError("Missing the required parameter `service_account_json` when calling `create_cs_gcp_connector`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_cs_gcp_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'connector_id' in params:
            query_params.append(('connectorId', params['connector_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'service_account_json' in params:
            local_var_files['serviceAccountJson'] = params['service_account_json']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/gcp/connector', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cs_registry(self, body, **kwargs):  # noqa: E501
        """Create a new registry  # noqa: E501

        Create a new registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_registry(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegistryRequest body: Provide parameter values in the format shown under Example Value. Parameters accountId, arn, and region are required when the registryType is AWS ECR and you want to create a new AWS connector. Specify the ARN if you want to use an existing AWS connector, or if you want to create a new connector. All parameters are required other than dockerHubOrgName which is optional. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cs_registry_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cs_registry_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_cs_registry_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new registry  # noqa: E501

        Create a new registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_registry_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegistryRequest body: Provide parameter values in the format shown under Example Value. Parameters accountId, arn, and region are required when the registryType is AWS ECR and you want to create a new AWS connector. Specify the ARN if you want to use an existing AWS connector, or if you want to create a new connector. All parameters are required other than dockerHubOrgName which is optional. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cs_registry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_cs_registry`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cs_registry_schedule(self, body, registry_id, **kwargs):  # noqa: E501
        """Create a new Registry scan schedule  # noqa: E501

        Create a new Registry scan schedule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_registry_schedule(body, registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: Provide parameter values in the format shown under Example Value. Specify "onDemand": true if you want to scan immediately. Otherwise, Automatic scan will be triggered everyday at a set time. For days, specify 1 to 7 days / 14 (for last two weeks). For schedule, specify time in UTC, e.g., 19:30. (required)
        :param str registry_id: Provide the ID of the registry for which you want to scan. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cs_registry_schedule_with_http_info(body, registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cs_registry_schedule_with_http_info(body, registry_id, **kwargs)  # noqa: E501
            return data

    def create_cs_registry_schedule_with_http_info(self, body, registry_id, **kwargs):  # noqa: E501
        """Create a new Registry scan schedule  # noqa: E501

        Create a new Registry scan schedule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cs_registry_schedule_with_http_info(body, registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: Provide parameter values in the format shown under Example Value. Specify "onDemand": true if you want to scan immediately. Otherwise, Automatic scan will be triggered everyday at a set time. For days, specify 1 to 7 days / 14 (for last two weeks). For schedule, specify time in UTC, e.g., 19:30. (required)
        :param str registry_id: Provide the ID of the registry for which you want to scan. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'registry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cs_registry_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_cs_registry_schedule`")  # noqa: E501
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `create_cs_registry_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/schedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cs_registries(self, **kwargs):  # noqa: E501
        """Delete multiple registries in your account  # noqa: E501

        Delete multiple registries in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registries(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cs_registries_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_cs_registries_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_cs_registries_with_http_info(self, **kwargs):  # noqa: E501
        """Delete multiple registries in your account  # noqa: E501

        Delete multiple registries in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cs_registries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cs_registry(self, registry_id, **kwargs):  # noqa: E501
        """Delete registry in you account  # noqa: E501

        Delete registry in you account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registry(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID/UUID of the registry you want to delete. Note: You cannot delete a registry whose schedules are in “Running” state. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cs_registry_with_http_info(registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cs_registry_with_http_info(registry_id, **kwargs)  # noqa: E501
            return data

    def delete_cs_registry_with_http_info(self, registry_id, **kwargs):  # noqa: E501
        """Delete registry in you account  # noqa: E501

        Delete registry in you account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registry_with_http_info(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID/UUID of the registry you want to delete. Note: You cannot delete a registry whose schedules are in “Running” state. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cs_registry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `delete_cs_registry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cs_registry_schedule(self, registry_id, schedule_id, **kwargs):  # noqa: E501
        """Delete registry schedule in your account  # noqa: E501

        Delete registry schedule in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registry_schedule(registry_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry you want to delete. (required)
        :param str schedule_id: Provide the ID/UUID of the schedule you want to delete. Note: You cannot delete a schedule which is in “Running” state. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cs_registry_schedule_with_http_info(registry_id, schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cs_registry_schedule_with_http_info(registry_id, schedule_id, **kwargs)  # noqa: E501
            return data

    def delete_cs_registry_schedule_with_http_info(self, registry_id, schedule_id, **kwargs):  # noqa: E501
        """Delete registry schedule in your account  # noqa: E501

        Delete registry schedule in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registry_schedule_with_http_info(registry_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry you want to delete. (required)
        :param str schedule_id: Provide the ID/UUID of the schedule you want to delete. Note: You cannot delete a schedule which is in “Running” state. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id', 'schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cs_registry_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `delete_cs_registry_schedule`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if ('schedule_id' not in params or
                params['schedule_id'] is None):
            raise ValueError("Missing the required parameter `schedule_id` when calling `delete_cs_registry_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501
        if 'schedule_id' in params:
            path_params['scheduleId'] = params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/schedule/{scheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cs_registry_schedules(self, registry_id, **kwargs):  # noqa: E501
        """Delete multiple registry schedules in your account  # noqa: E501

        Delete multiple registry schedules in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registry_schedules(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry for which you want to delete. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cs_registry_schedules_with_http_info(registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cs_registry_schedules_with_http_info(registry_id, **kwargs)  # noqa: E501
            return data

    def delete_cs_registry_schedules_with_http_info(self, registry_id, **kwargs):  # noqa: E501
        """Delete multiple registry schedules in your account  # noqa: E501

        Delete multiple registry schedules in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cs_registry_schedules_with_http_info(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry for which you want to delete. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cs_registry_schedules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `delete_cs_registry_schedules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/schedule', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_acr_connectors_by_aws_account_id_using_get(self, connector_id, **kwargs):  # noqa: E501
        """Show ACR connector details  # noqa: E501

        Show ACR connector details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_acr_connectors_by_aws_account_id_using_get(connector_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_id: Provide the ACR connector Id to get connector details. (required)
        :return: AcrConnector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_acr_connectors_by_aws_account_id_using_get_with_http_info(connector_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_acr_connectors_by_aws_account_id_using_get_with_http_info(connector_id, **kwargs)  # noqa: E501
            return data

    def get_cs_acr_connectors_by_aws_account_id_using_get_with_http_info(self, connector_id, **kwargs):  # noqa: E501
        """Show ACR connector details  # noqa: E501

        Show ACR connector details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_acr_connectors_by_aws_account_id_using_get_with_http_info(connector_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_id: Provide the ACR connector Id to get connector details. (required)
        :return: AcrConnector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_acr_connectors_by_aws_account_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_id' is set
        if ('connector_id' not in params or
                params['connector_id'] is None):
            raise ValueError("Missing the required parameter `connector_id` when calling `get_cs_acr_connectors_by_aws_account_id_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_id' in params:
            path_params['connectorId'] = params['connector_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/acr/connector/{connectorId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AcrConnector',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_acr_connectors_list_using_get(self, **kwargs):  # noqa: E501
        """Show list of ACR connectors in your account  # noqa: E501

        Show list of ACR connectors in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_acr_connectors_list_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[AcrConnector]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_acr_connectors_list_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_acr_connectors_list_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cs_acr_connectors_list_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Show list of ACR connectors in your account  # noqa: E501

        Show list of ACR connectors in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_acr_connectors_list_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[AcrConnector]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_acr_connectors_list_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/acr/connectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AcrConnector]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_aws_account_id_using_get(self, **kwargs):  # noqa: E501
        """Fetch AWS account ID and external ID for your account  # noqa: E501

        Fetch AWS account ID and external ID for your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_aws_account_id_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_aws_account_id_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_aws_account_id_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cs_aws_account_id_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetch AWS account ID and external ID for your account  # noqa: E501

        Fetch AWS account ID and external ID for your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_aws_account_id_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_aws_account_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/aws-base', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AwsAccount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_aws_connectors_by_aws_account_id_using_get(self, account_id, **kwargs):  # noqa: E501
        """Show list of AWS connectors for an AWS account ID  # noqa: E501

        Show list of AWS connectors for an AWS account ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_aws_connectors_by_aws_account_id_using_get(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Provide the AWS account Id to get a list of connectors. (required)
        :return: list[AwsConnector]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_aws_connectors_by_aws_account_id_using_get_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_aws_connectors_by_aws_account_id_using_get_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_cs_aws_connectors_by_aws_account_id_using_get_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Show list of AWS connectors for an AWS account ID  # noqa: E501

        Show list of AWS connectors for an AWS account ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_aws_connectors_by_aws_account_id_using_get_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Provide the AWS account Id to get a list of connectors. (required)
        :return: list[AwsConnector]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_aws_connectors_by_aws_account_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_cs_aws_connectors_by_aws_account_id_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/aws/connectors/{accountId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AwsConnector]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_aws_connectors_list_using_get(self, **kwargs):  # noqa: E501
        """Show list of AWS connectors in your account  # noqa: E501

        Show list of AWS connectors in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_aws_connectors_list_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsConnector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_aws_connectors_list_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_aws_connectors_list_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cs_aws_connectors_list_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Show list of AWS connectors in your account  # noqa: E501

        Show list of AWS connectors in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_aws_connectors_list_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsConnector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_aws_connectors_list_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/aws/connectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AwsConnector',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_gcp_connectors_by_gcp_connector_id_using_get(self, connector_id, **kwargs):  # noqa: E501
        """Get GCP connector by connectorId  # noqa: E501

        Get GCP connector by connectorId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_gcp_connectors_by_gcp_connector_id_using_get(connector_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_id: Provide the GCP connector Id to get connector details. (required)
        :return: GcpConnector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_gcp_connectors_by_gcp_connector_id_using_get_with_http_info(connector_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_gcp_connectors_by_gcp_connector_id_using_get_with_http_info(connector_id, **kwargs)  # noqa: E501
            return data

    def get_cs_gcp_connectors_by_gcp_connector_id_using_get_with_http_info(self, connector_id, **kwargs):  # noqa: E501
        """Get GCP connector by connectorId  # noqa: E501

        Get GCP connector by connectorId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_gcp_connectors_by_gcp_connector_id_using_get_with_http_info(connector_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_id: Provide the GCP connector Id to get connector details. (required)
        :return: GcpConnector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_gcp_connectors_by_gcp_connector_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_id' is set
        if ('connector_id' not in params or
                params['connector_id'] is None):
            raise ValueError("Missing the required parameter `connector_id` when calling `get_cs_gcp_connectors_by_gcp_connector_id_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_id' in params:
            path_params['connectorId'] = params['connector_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/gcp/connector/{connectorId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GcpConnector',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_gcp_connectors_list_using_get(self, **kwargs):  # noqa: E501
        """Show list of GCP connectors in your account  # noqa: E501

        Show list of GCP connectors in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_gcp_connectors_list_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[GcpConnector]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_gcp_connectors_list_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_gcp_connectors_list_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cs_gcp_connectors_list_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Show list of GCP connectors in your account  # noqa: E501

        Show list of GCP connectors in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_gcp_connectors_list_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[GcpConnector]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_gcp_connectors_list_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/gcp/connectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GcpConnector]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_registries_data_using_get(self, **kwargs):  # noqa: E501
        """Show a list of registries in your account  # noqa: E501

        Show a list of registries in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registries_data_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter the registries list by providing a query using Qualys syntax.
        :param int page_number: The page to be returned.
        :param int page_size: The number of records per page to be included in the response.
        :param str sort: Sort the results using a Qualys token.
        :return: Registries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_registries_data_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_registries_data_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cs_registries_data_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Show a list of registries in your account  # noqa: E501

        Show a list of registries in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registries_data_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Filter the registries list by providing a query using Qualys syntax.
        :param int page_number: The page to be returned.
        :param int page_size: The number of records per page to be included in the response.
        :param str sort: Sort the results using a Qualys token.
        :return: Registries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page_number', 'page_size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_registries_data_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('pageNumber', params['page_number']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Registries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_registry_details(self, registry_id, **kwargs):  # noqa: E501
        """Show details of a registry  # noqa: E501

        Show details of a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registry_details(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID/UUID of the registry you want to fetch the details. (required)
        :return: RegistryDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_registry_details_with_http_info(registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_registry_details_with_http_info(registry_id, **kwargs)  # noqa: E501
            return data

    def get_cs_registry_details_with_http_info(self, registry_id, **kwargs):  # noqa: E501
        """Show details of a registry  # noqa: E501

        Show details of a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registry_details_with_http_info(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID/UUID of the registry you want to fetch the details. (required)
        :return: RegistryDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_registry_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `get_cs_registry_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistryDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_registry_repositories(self, registry_id, **kwargs):  # noqa: E501
        """Show a list of repositories in a registry  # noqa: E501

        Show a list of repositories in a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registry_repositories(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry for which you want to list the repositories. (required)
        :param str filter: Filter the repository list by providing a query using Qualys syntax.
        :param int page_number: The page to be returned.
        :param int page_size: The number of records per page to be included in the response.
        :param str sort: Sort the results using a Qualys token.
        :return: Repositories
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_registry_repositories_with_http_info(registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_registry_repositories_with_http_info(registry_id, **kwargs)  # noqa: E501
            return data

    def get_cs_registry_repositories_with_http_info(self, registry_id, **kwargs):  # noqa: E501
        """Show a list of repositories in a registry  # noqa: E501

        Show a list of repositories in a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registry_repositories_with_http_info(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry for which you want to list the repositories. (required)
        :param str filter: Filter the repository list by providing a query using Qualys syntax.
        :param int page_number: The page to be returned.
        :param int page_size: The number of records per page to be included in the response.
        :param str sort: Sort the results using a Qualys token.
        :return: Repositories
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id', 'filter', 'page_number', 'page_size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_registry_repositories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `get_cs_registry_repositories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('pageNumber', params['page_number']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/repository', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repositories',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cs_registry_schedules(self, registry_id, **kwargs):  # noqa: E501
        """Show a list of schedules created for a registry  # noqa: E501

        Show a list of schedules created for a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registry_schedules(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry for which you want to list the schedules. (required)
        :param str filter: Filter the schedules list by providing a query using Qualys syntax.
        :param int page_number: The page to be returned.
        :param int page_size: The number of records per page to be included in the response.
        :param str sort: Sort the results using a Qualys token.
        :return: Schedules
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cs_registry_schedules_with_http_info(registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cs_registry_schedules_with_http_info(registry_id, **kwargs)  # noqa: E501
            return data

    def get_cs_registry_schedules_with_http_info(self, registry_id, **kwargs):  # noqa: E501
        """Show a list of schedules created for a registry  # noqa: E501

        Show a list of schedules created for a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cs_registry_schedules_with_http_info(registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registry_id: Provide the ID of the registry for which you want to list the schedules. (required)
        :param str filter: Filter the schedules list by providing a query using Qualys syntax.
        :param int page_number: The page to be returned.
        :param int page_size: The number of records per page to be included in the response.
        :param str sort: Sort the results using a Qualys token.
        :return: Schedules
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registry_id', 'filter', 'page_number', 'page_size', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cs_registry_schedules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `get_cs_registry_schedules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('pageNumber', params['page_number']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/schedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schedules',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cs_registry(self, body, registry_id, **kwargs):  # noqa: E501
        """Update exiting registry in your account  # noqa: E501

        Update exiting registry in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cs_registry(body, registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegistryRequest body: Provide parameter values in the format shown under Example Value. registryType and registryUri are required even though they are not updatable. (required)
        :param str registry_id: Provide the ID/UUID of the registry you want to update. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cs_registry_with_http_info(body, registry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cs_registry_with_http_info(body, registry_id, **kwargs)  # noqa: E501
            return data

    def update_cs_registry_with_http_info(self, body, registry_id, **kwargs):  # noqa: E501
        """Update exiting registry in your account  # noqa: E501

        Update exiting registry in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cs_registry_with_http_info(body, registry_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegistryRequest body: Provide parameter values in the format shown under Example Value. registryType and registryUri are required even though they are not updatable. (required)
        :param str registry_id: Provide the ID/UUID of the registry you want to update. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'registry_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cs_registry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cs_registry`")  # noqa: E501
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `update_cs_registry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cs_registry_schedule(self, body, registry_id, schedule_id, **kwargs):  # noqa: E501
        """Update existing registry schedule in your account  # noqa: E501

        Update existing registry schedule in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cs_registry_schedule(body, registry_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: Provide parameter values in the format shown under Example Value. Specify "onDemand": true if you want to scan immediately. Otherwise, Automatic scan will be triggered everyday at a set time. For days, specify 1 to 7 days / 14 (for last two weeks). For schedule, specify time in UTC, e.g., 19:30. (required)
        :param str registry_id: Provide the ID of the registry you want to update. (required)
        :param str schedule_id: Provide the ID/UUID of the schedule you want to update. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cs_registry_schedule_with_http_info(body, registry_id, schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cs_registry_schedule_with_http_info(body, registry_id, schedule_id, **kwargs)  # noqa: E501
            return data

    def update_cs_registry_schedule_with_http_info(self, body, registry_id, schedule_id, **kwargs):  # noqa: E501
        """Update existing registry schedule in your account  # noqa: E501

        Update existing registry schedule in your account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cs_registry_schedule_with_http_info(body, registry_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: Provide parameter values in the format shown under Example Value. Specify "onDemand": true if you want to scan immediately. Otherwise, Automatic scan will be triggered everyday at a set time. For days, specify 1 to 7 days / 14 (for last two weeks). For schedule, specify time in UTC, e.g., 19:30. (required)
        :param str registry_id: Provide the ID of the registry you want to update. (required)
        :param str schedule_id: Provide the ID/UUID of the schedule you want to update. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'registry_id', 'schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cs_registry_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cs_registry_schedule`")  # noqa: E501
        # verify the required parameter 'registry_id' is set
        if ('registry_id' not in params or
                params['registry_id'] is None):
            raise ValueError("Missing the required parameter `registry_id` when calling `update_cs_registry_schedule`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if ('schedule_id' not in params or
                params['schedule_id'] is None):
            raise ValueError("Missing the required parameter `schedule_id` when calling `update_cs_registry_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registry_id' in params:
            path_params['registryId'] = params['registry_id']  # noqa: E501
        if 'schedule_id' in params:
            path_params['scheduleId'] = params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/{registryId}/schedule/{scheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_cs_registry(self, body, **kwargs):  # noqa: E501
        """Validate information for new registry  # noqa: E501

        Validate information for new registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_cs_registry(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegistryRequest body: Validate parameters for a registry you intend to create. Provide parameter values in the format shown under Example Value. Parameters accountId, arn, and region are required when the registryType is AWS ECR and you want to create a new AWS connector. Specify the ARN if you want to use an existing AWS connector, or if you want to create a new connector. All parameters are required other than dockerHubOrgName which is optional. (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_cs_registry_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_cs_registry_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def validate_cs_registry_with_http_info(self, body, **kwargs):  # noqa: E501
        """Validate information for new registry  # noqa: E501

        Validate information for new registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_cs_registry_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegistryRequest body: Validate parameters for a registry you intend to create. Provide parameter values in the format shown under Example Value. Parameters accountId, arn, and region are required when the registryType is AWS ECR and you want to create a new AWS connector. Specify the ARN if you want to use an existing AWS connector, or if you want to create a new connector. All parameters are required other than dockerHubOrgName which is optional. (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_cs_registry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `validate_cs_registry`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registry/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
